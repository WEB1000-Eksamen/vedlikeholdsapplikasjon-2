<?php

namespace Imgur\Auth;

use Imgur\Listener;
use Imgur\Exception\AuthException;

/**
 * Authentication class used for handling OAuth2
 *
 * @author Adrian Ghiuta <adrian.ghiuta@gmail.com>
 */

class OAuth2 implements \Imgur\Auth\AuthInterface {
    /**
     * Indicates the client that is making the request.
     * 
     * @var string 
     */
    private $clientId;

    /**
     * The client_secret for the application
     * 
     * @var string 
     */
    private $clientSecret;    

    /**
     * The access token and refresh token values
     * 
     * @var array
     */
    private $token;    
        
    const AUTHORIZATION_ENDPOINT = 'https://api.imgur.com/oauth2/authorize';
    const ACCESS_TOKEN_ENDPOINT = 'https://api.imgur.com/oauth2/token';
    
    /**
     * Instantiates the OAuth2 class, but does not trigger the authentication process
     * 
     * @param string $clientId
     * @param string $clientSecret
     */
    public function __construct($clientId, $clientSecret) {
        $this->clientId = $clientId;
        $this->clientSecret = $clientSecret;
    }
    
    /**
     * Generates the authentication URL to which a user should be pointed at in order to start the OAuth2 process
     * 
     * @param string $responseType
     * @param null|string $state
     * @return string
     */
    public function getAuthenticationURL($responseType = 'code', $state = null) {
        $httpQueryParameters = array(
            'client_id' => $this->clientId,
            'response_type' => $responseType,
            'state' => $state
        );
        
        $httpQueryParameters = http_build_query($httpQueryParameters);
        
        return self::AUTHORIZATION_ENDPOINT.'?'.$httpQueryParameters;
    }

    /**
     * Exchanges a code/pin for an access token
     * 
     * @param string $code
     * @param string $requestType
     * @return string
     */
    public function requestAccessToken($code, $requestType, $httpClient) {
        switch ($requestType) {
            case 'code':
                $grantType = 'authorization_code';
                $type = 'code';
                break;
            case 'pin':
                $grantType = 'pin';
                $type = 'pin';
                break;
            default:
                $grantType = 'authorization_code';
                $type = 'code';
                break;
        }
        $response = $httpClient->post(self::ACCESS_TOKEN_ENDPOINT, 
                                      array(
                                          'client_id' => $this->clientId,
                                          'client_secret' => $this->clientSecret,
                                          'grant_type' => $grantType,
                                          $type => $code
                                      ));

        $responseBody = json_decode($response->getBody(true), true);
        
        if($response->getStatusCode() == 200) {
            $responseBody['created_at'] = time();
            $this->setAccessToken($responseBody, $httpClient);
        }
        else {
            throw new AuthException('Request for access token failed. '.$responseBody['error'], $response->getStatusCode());
        }
        
        $this->sign($httpClient);
        
        return $responseBody;
    }
    
    /**
     * If a user has authorized their account but you no longer have a valid access_token for them, 
     * then a new one can be generated by using the refresh_token.
     * When your application receives a refresh token, it is important to store that refresh token for future use. 
     * If your application loses the refresh token, 
     * you will have to prompt the user for their login information again.
     * 
     * @return array
     * @throws AuthException
     */
    public function refreshToken($httpClient) {
        $token = $this->getAccessToken();
        
        $response = $httpClient->post(self::ACCESS_TOKEN_ENDPOINT, 
                                      array(
                                          'refresh_token' => $token['refresh_token'],
                                          'client_id' => $this->clientId,
                                          'client_secret' => $this->clientSecret,
                                          'grant_type' => 'refresh_token'
                                      ));

        $responseBody = json_decode($response->getBody(true), true);

        if($response->getStatusCode() == 200) {
            $this->setAccessToken($responseBody, $httpClient);
        }
        else {
            throw new AuthException('Request for refresh access token failed. '.$responseBody['error'], $response->getStatusCode());
        }
        
        $this->sign($httpClient);
        
        return $responseBody;        
    }

    /**
     * Stores the access token, refresh token and expiration date
     * 
     * @param array $token
     * @throws AuthException
     * @return array
     */
    public function setAccessToken($token, $httpClient) {
        if ($token == null) {
          throw new AuthException('Token is not a valid json string.');
        }
        
        if ( isset($token['data']['access_token'])) {
          $token = $token['data'];
        }

        
        if (! isset($token['access_token'])) {
          throw new AuthException('Access token could not be retrieved from the decoded json response.');
        }

        $this->token = $token;  
        
        $this->sign($httpClient);
    }

    /**
     * Getter for the current access token
     * 
     * @return array
     */
    public function getAccessToken() {
        
        return $this->token;
    }
    
    /**
     * Check if the current access token (if present), is still usable
     * 
     * @return bool
     */
    public function checkAccessTokenExpired() {
        $expirationTime = $this->token['created_at'] + $this->token['expires_in'];

        return $expirationTime < time();        
    }
    
    /**
     * Attaches the triggers needed for attaching the header signature to each request
     * 
     * @param HttpClient $httpClient
     */
    public function sign($httpClient) {
        $token = $this->getAccessToken();
        
        $this->addListener($httpClient, 'request.before_send', array(
            new Listener\AuthListener($token, $this->clientId), 'onRequestBeforeSend'
        ));        
    }
    
    /**
     * Attaches a listener to a HttpClient event
     * 
     * @param HttpClient $httpClient
     * @param string $eventName
     * @param array $listener
     */
    public function addListener($httpClient, $eventName, $listener) {
        $httpClient->addListener($eventName, $listener);
    }    
}
